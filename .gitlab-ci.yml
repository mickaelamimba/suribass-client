stages:
  - build
  - deploy

variables:
  IMAGE_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
  LATEST_TAG: $CI_REGISTRY_IMAGE:latest

# Build de l'image
build:
  stage: build
  image: docker:latest
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
  script:
    - docker build 
      --build-arg NEXT_PUBLIC_API_URL=$NEXT_PUBLIC_API_URL 
      --build-arg NEXT_PUBLIC_API_BASE_URL=$NEXT_PUBLIC_API_BASE_URL
      --build-arg NEXT_PUBLIC_GOOGLE_CLIENT_ID=$NEXT_PUBLIC_GOOGLE_CLIENT_ID
      -t $IMAGE_TAG -t $LATEST_TAG -f Dockerfile .
    - docker push $IMAGE_TAG
    - docker push $LATEST_TAG
  only:
    - main
    - develop
  tags:
    - docker

# DÃ©ploiement Production
deploy_production:
  stage: deploy
  image: docker:latest
  before_script:
    - apk add --no-cache docker-cli-compose
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY

  script:
    # Dossier de dÃ©ploiement
    - mkdir -p /opt/suribass-client

    # Copier le docker-compose
    - cp docker-compose.prod.yml /opt/suribass-client/docker-compose.yml

    # GÃ©nÃ©rer l'environnement
    - echo "NEXT_PUBLIC_API_URL=$NEXT_PUBLIC_API_URL" > /opt/suribass-client/.env
    - echo "NEXT_PUBLIC_API_BASE_URL=$NEXT_PUBLIC_API_BASE_URL" >> /opt/suribass-client/.env
    - echo "NEXT_PUBLIC_GOOGLE_CLIENT_ID=$NEXT_PUBLIC_GOOGLE_CLIENT_ID" >> /opt/suribass-client/.env
    - echo "API_BASE_URL=$API_BASE_URL" >> /opt/suribass-client/.env

    # DÃ©ploiement
    - cd /opt/suribass-client
    - docker compose --env-file .env pull frontend
    - docker compose --env-file .env up -d frontend
    - docker image prune -af
    - echo "ðŸš€ Frontend dÃ©ployÃ© en production"
    

  environment:
    name: production
  only:
    - main
  tags:
    - docker
  when: manual
